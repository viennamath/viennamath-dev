
\chapter*{Introduction}   \addcontentsline{toc}{chapter}{Introduction} \label{intro}

The beginning of the computing era is inherently linked with the use of computing devices for numerical algorithms.
While the first implementations had been carried out in assembly language, the FORTRAN language then provided a means for efficiently abstracting the underlying hardware.
%However, even today the implementation of mathematical algorithms is accomplished in \emph{FORTRAN-style}, i.e. numbers are manipulated at an array level.
This approach to programming is still common for the implementation of numerical algorithms today:
Mathematical primitives such as polynomials or functions are in one way or another represented as an array of numbers already in user code.
The mathematical meaning of these numbers is, if at all, only implicitly deducible for a programmer.

Abstraction facilities provided by modern programming languages such as C++ are much more powerful and mature compared to an abstraction at an array level.
However, implementation guidelines in numerical textbooks written in the past cannot reflect the current state-of-the-art in programming,
thus algorithms are often still implemented without making use of additional abstraction mechanisms.
One of the reasons is that first attemps of using object-oriented programming have reported poor performance due to additional indirections at runtime.
However, this issue (and several others) have been adressed by language improvements and/or programming techniques.

The aim of {\ViennaMath} is to show by example that preserving the mathematical abstraction by means of a symbolic math engine can make code much more readable without sacrificing performance.
Even though {\ViennaMath} makes use of object-oriented programming, certain calculations and optimizations can already be carried out already at compile time, thus eliminating many expensive indirections at runtime.
Consequently, the process of hand-tuning code, i.e.~the use of information already available at compile time, is shifted from the user to the compiler.
This increases productivity without reducing performance.


%% Mention related work



%% Why ViennaMath is 'better':




