\chapter{Expression Manipulation} \label{chap:manipulation}

The basic description of the types in Chap.~\ref{chap:basics} allows for defining expressions and evaluating them.
However, for most algorithms expressions need to be manipulated in one way or another, which is the topic of this chapter.
Unless otherwise noted, all manipulations considerered in the following can be used for both compiletime and runtime expressions using the same interface.

\TIP{Manipulation functionality resides in folder \lstinline|viennamath/manipulation/|.
 The respective header files are not included automatically with \lstinline|viennamath/expression.hpp| and need to be included as required.}

 \section{Evaluation}
All {\ViennaMath} expressions can be evaluated to a floating point number using the parenthesis operator.
Depending on the number of variables in the expression, either a scalar or a vector needs to be passed for evaluation.

Using \lstinline|operator()|, however, is possibly not an option for a generic interface with non-ViennaMath types.
For this reason, \lstinline|viennamath::eval()| provides a generic evaluation interface. 
The first argument is the expression to be evaluated, and the second argument is the tuple with the values to be substituted for the variables.
For example, the expression $x^2$ is defined and evaluated at $x=2$ as follows:
\begin{lstlisting}
 ct_constant<2> c2;
 ct_variable<0> x;
 eval( x*x, 2.0 ); //     runtime evaluation
 eval( x*x,  c2 ); // compiletime evaluation
\end{lstlisting}
Note that compiletime evaluation is only performed when both arguments are fully compiletime compatible.
As soon as one part of the expression cannot be handled at compile time, a fallback to runtime evaluation is carried out.
A hybrid evaluation in such cases is postponed to future releases of {\ViennaMath}.

A vector of values needs to be passed as second argument, if a variable formally refers to any other than the first coordinate in a vector.
Let us consider several use-cases of \lstinline|eval()| consisting of various combinations of compiletime and runtime expressions:
\begin{lstlisting}
 ct_constant<3> c3;
 ct_variable<1> y;
 expr f = x*x + y;     // conversion to runtime expression
 eval( f, 2.0 );       // runtime exception: insufficient values provided
 eval( x*x + y, c2 );  // compilation error: insufficient values provided
 eval( x*x + y,
       make_vector(2.0, 3.0) ); //    runtime evaluation
 eval( x*x + y,
       make_vector(c2, c3) );  // compiletime evaluation
 eval( 2.0, 0.0 );             // possible thanks to overloading
\end{lstlisting}
Since the runtime wrapper \lstinline|expr| hides information from the compiler, an exception is thrown at runtime if insufficient values are provided for evaluation.
For a full compiletime evaluation, insufficient parameters are already detected at an earlier stage.
The helper function \lstinline|make_vector() | generates a suitable vector type both for the runtime and the compiletime case.
Instead of using \lstinline|make_vector()|, a STL vector (\lstinline|std::vector<double>|) or any compatible type can also be passed.
Also note that the last line in the code snippet shows the benefit of using \lstinline|eval()| instead of \lstinline|operator()|:
Scalars can also be 'evaluated' and are thus reinterpreted as constant functions.

 \section{Substitution}
Formally, the evaluation of an expression can be seen as a substitution of the variables with values.
A generalization is to replace arbitrary expressions with another expression in third expression.
This is accomplished by the function \lstinline|substitute()| defined in \lstinline|viennamath/manipulation/substitute.hpp|:
\begin{lstlisting}
 expr f = (x + y) * (x - y);
 substitute(x, y, f);         // returns (y + y) * (y - y) = 0
 substitute(x, 1, f);         // returns (1 + y) * (1 - y)
 substitute(x + y, x - y, f); // returns (x - y) * (x - y)
\end{lstlisting}
As with \lstinline|eval|, substitutions are carried out at compiletime if all parameters are compiletime expressions.


 \section{Expansion}
It is often desired to expand an expression given as a product of other terms. For example, instead of $2(x+y)$ one may want to have $2x - 2y$.
Such a functionality is provided by the function \lstinline|expand()| defined in \lstinline|viennamath/manipulation/expand.hpp|:
\begin{lstlisting}
 expand( c2 * (x+y) );
\end{lstlisting}
where \lstinline|c2| is a compiletime constant and \lstinline|x|, \lstinline|y| are compiletime variables.
Note that {\ViennaMathversion} does not support the expansion of runtime expressions yet.

\NOTE{ {\ViennaMathversion} supports compiletime expansion only. }



 \section{Simplification}
In the course of manipulating expressions, simple operations such as $x+0$ or $x/1$ may appear.
However, such terms constitute unnecessary overhead for later evaluations, thus it is desirable to have these operations dropped.
Such a simplification of the expression can be achieved with the function \lstinline|simplify()| defined in \lstinline|viennamath/manipulation/simplify.hpp|:
\begin{lstlisting}
 simplify( x + 1.0 * y - 0.0 );  // returns x
 simplify( x * (2.0 + 3.0) + (y * 0) / (x * 1) ); // returns 5x
\end{lstlisting}
\lstinline|simplify()| is available both for runtime and compiletime manipulation.


 \section{Differentation}



 \section{Integration}

 %% Compiletime: Analytic

 %% Runtime: Quadrature


 \section{Extract Coefficient}


\NOTE{ \lstinline|coefficient()| is in {\ViennaMathversion} available for compiletime types only. }


 \section{Drop Dependent Terms}



\NOTE{ \lstinline|drop_dependent_terms()| is in {\ViennaMathversion} available for compiletime types only. }


